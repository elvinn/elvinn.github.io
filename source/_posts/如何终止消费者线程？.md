---
title: 如何终止消费者线程？
tags:
  - python
date: 2016-11-27 22:50:45
---

最近在做 [黄网嗅探器](https://github.com/Leonard-Peng/HungrySpider) 的时候，因为单线程版实在太慢，大部分时间都用在了网络 IO上，因而想着利用**生产者-消费者模型**做出多线程版，把网址的生成部分当作生产者线程，网址是否为黄网的检测部分当作消费者线程。不过在实现的过程中，碰到了一个问题：当网址的全部组合已生成完毕后，如何由生产者通知消费者，进而待网址检测完成后终止消费者线程呢？

<!--more-->
> 生产者-消费者模型中需要注意的一些其他问题可以参考：[Producer-consumer problem in Python](http://agiliq.com/blog/2013/10/producer-consumer-problem-in-python/) 或者相应的中文翻译 [Python中的生产者-消费者问题](http://blog.jobbole.com/52412/)

## 终止消费者线程的两种方法

终止消费者线程有两种方法：

1.  消费者设置等待时间限制，当一段时间过后消费者未接受到任务时自行结束线程。
2.  当生产者完成生产后通过设定的标志通知消费者，进而消费者结束线程。

由于第一种方法较为简单，因而下面先讲解第一种方法，再讲解第二种方法。

## 方法一：消费者设置等待时间限制

在 python 中，`Queue.Queue` 的 `get` 方法可以设置等待时长，当超过等待时长后仍无法从队列中获取元素时，会抛出 `Queue.Empty` 的异常，通过捕捉这个异常就可以判断为生产者的生产已经结束，从而结束消费者线程。

具体的例子如下：

```python
# -*- coding: utf8 -*-
from threading import Thread
from Queue import Queue, Empty
import time
queue = Queue(10)
class Producer(Thread):
    def run(self):
        global queue
        for i in xrange(10):
            queue.put(i)
            time.sleep(0.1)
class Consumer(Thread):
    def run(self):
        global queue
        try:
            while True:
                num = queue.get(timeout=1) # 设置等待时长为 1 s
                queue.task_done()
                print self.getName(), ' Consumed ', num
                time.sleep(0.05)
        except Empty: 
            # 捕捉异常，输出结束信息 
            print self.getName(), ' done.' 
if __name__ == '__main__':
    p1 = Producer()
    p1.start()
    c1 = Consumer()
    c1.start()
    c2 = Consumer()
    c2.start()
    c1.join()
    p1.join()
    c2.join()
    print 'Ended'
```

## 方法二：生产者结束生产后设定结束标志

当生产者结束生产后，可以往队列中送入与消费者个数相同的标志（None 是个不错的选择)，当消费者从队列中取到结束标志后，便结束本身的线程。

当只有一个生产者时，情况比较简单，例子如下：

```javascript
# -*- coding: utf8 -*-
from threading import Thread
from Queue import Queue
import time
consumer_num = 2
queue = Queue(10)
class Producer(Thread):
    def run(self):
        global consumer_num
        global queue
        for i in xrange(10):
            queue.put(i)
            time.sleep(0.1)
        for i in xrange(consumer_num):
            queue.put(None)
class Consumer(Thread):
    def run(self):
        global queue
        while True:
            num = queue.get(timeout=1)
            if num is None:
                break
            queue.task_done()
            print self.getName(), ' Consumed ', num
            time.sleep(0.05)
        print self.getName(), ' done.'
if __name__ == '__main__':
    p1 = Producer()
    p1.start()
    consumer_list = list()
    for i in xrange(consumer_num):
        consumer_list.append(Consumer())
        consumer_list[i].start()
    p1.join()
    for i in xrange(consumer_num):
        consumer_list[i].join()
    print 'Ended'
```

当有多个生产者时，不能像上面一样，当一个生产者结束生产后就向全部消费者发送终止信息。此时具体有如下两种处理方式：

1.  纪录全部生产者的生产状况，当全部生产者结束生产后，再往队列中放入终止信息。
2.  将生产者与消费者进行分组绑定，当一个生产者结束生产之后便向与其一组的消费者发送终止信息。

下面给出第一种处理方式的例子：

```javascript
# -*- coding: utf8 -*-
from threading import Thread
from Queue import Queue
import time
producer_num = 2
consumer_num = 5
producers_state = 0
queue = Queue(10)
class Producer(Thread):
    def run(self):
        global producer_num
        global consumer_num
        global producers_state
        global queue
        for i in xrange(10):
            queue.put(i)
            time.sleep(0.1)
        producers_state += 1
        if producers_state == producer_num:
            for i in xrange(consumer_num):
                queue.put(None)
class Consumer(Thread):
    def run(self):
        global queue
        while True:
            num = queue.get(timeout=1)
            if num is None:
                break
            queue.task_done()
            time.sleep(0.05)
    
if __name__ == '__main__':
    producer_list = list()
    for i in xrange(producer_num):
        producer_list.append(Producer())
        producer_list[i].start()
    consumer_list = ist()
    for i in xrange(consumer_num):
        consumer_list.append(Consumer())
        consumer_list[i].start()
    for i in xrange(producer_num):
        producer_list[i].join()
    for i in xrange(consumer_num):
        consumer_list[i].join()
    print 'Ended'
```

> 消费者数目较多时，输出比较乱，故删去只留下程序结束的输出。

## 两种方法的比较

对于第一种通过设置消费者等待时间限制的方法，其优点为：

1.  实现简单，无需考虑复杂逻辑，只要自己没事可干便结束自己。
2.  当生产者的生产速度大于消费者的消费速度时，这种方法完全适用。

但是它也有明显的缺点：

1.  等待时间的限制设置需要仔细考虑，避免还未结束生产便将消费者线程终结。
2.  当生产者的生产速度远大于消费者的消费速度，或者生产者的生产速度分布较为分散时，即等待的时间难以确定时，这种方法便完全丧失了用武之地。

对于第二种方法，除了实现复杂一点外（其实也没有复杂太多），基本上适用于任何情况，因而在实际运用中往往采用第二种方法–当生产者结束生产后向队列中放入结束标志，我在 [黄网嗅探器 V2.0](https://github.com/Leonard-Peng/HungrySpider) 中使用的便是这种方法。