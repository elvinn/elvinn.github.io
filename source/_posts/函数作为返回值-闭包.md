---
title: 函数作为返回值--闭包
tags:
  - python
date: 2016-11-17 22:43:34
---

当我们在函数A中又定义了函数B，并且内部函数B可以引用外部函数A的参数和局部变量，当A返回函数B时，相关参数和变量都保存在返回的函数中，这种程序结构称为**“闭包”（Closure）**。

<!--more-->

```python
#一个简单地例子
def lazy_sum(*args):
    def sum():
        a = 0
        for n in args:
            a += n
        return a
    return sum
```

当我们调用的_lazy_sum( )_时，返回的并不是求和结果，而是求和函数_sum( )_:

```python
>>> f = lazy_sum(1, 2, 3, 4, 5)
>>> f
<function sum at 0x4c43f0>
```

调用函数_f( )_时，才真正计算求和的结果：

```python
>>> f()
15
```

有一个需要特别注意的问题：返回的函数并没有立刻执行，而是直到调用了_f( )_才执行。

```python
#输出的结果会是多少？
def square_1():
    result = []
    for i in xrange(1, 4):
        def f():
            return ii
        result.append(f())
    return result
    
def square_2():
    result = []
    for i in xrange(1, 4):
        def f():
            return ii
        result.append(f)
    return result
    
print square_1()
print square_2()
f1, f2, f3 = square_2()
print f1(), f2(), f3()
```

你可能认为_f1( ), f2( ), f3( )_的结果应该是_1， 4， 9_，或者认为_square_1( ), square_2( )_的返回值相同， 但实际结果是：

```python
>>> print square_1()
[1, 4, 9]
>>> print square_2()
[<function f at 0x4c45b0>, <function f at 0x4c44f0>, <function f at 0x4c4570>]
>>> f1, f2, f3 = square_2()
>>> print f1(), f2(), f3()
9 9 9
```

1._square_1( )_中`result.append(f( ))`，_f( )_立刻被执行，因而返回值直接是计算结果的tuple， _suqre_2( )_中`result.append(f)`，因而返回值是函数f()的tuple，两者是完全不同的!
2._f1( ), f2( ), f3( )_的值全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。

**返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。** 

如果一定要引用循环变量的话，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。

```python
def square_3():
    def g(j):
        def f():
            return j*j
        return f
    result = []
    for i in xrange(1, 4):
        result.append(g(i))
    return result
```

我们来看看结果：

```python
>>> f1, f2, f3 = square_3()
>>> print f1(), f2(), f3()
1 4 9
```