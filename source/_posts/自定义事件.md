---
title: 自定义事件
tags:
  - 前端
  - JavaScript
date: 2016-12-16 10:51:35
---

 首先，我们要弄清楚什么是**事件**。在 W3School 上有这样一句话：

> HTML events are **“things”** that happen to HTML elements.

看起来充满了玄学，**things** 是什么鬼，这也太宽泛了把？对，就是这么宽泛：任何行为都可以充当事件！不论是浏览器已经支持的单击、双击、鼠标滑动等行为，还是我们一会儿要实现的自定义的三连击行为，一切的变化都可以充当事件，从而被观察者发现进而做出进一步的反应。

<!--more-->

事件是与 DOM 元素交互最常见的方式，通过自定义事件可以实现功能上的扩展，我会首先实现一个基于 DOM 的三连击事件。当然，事件也可以用于与 DOM 无关的代码中，这时候利用自定义事件则是为了通过叫做**观察者**的设计模式创建松散耦合的代码，具体的实现将在第二部分进行说明。

## 实现与 DOM 相关的自定义事件

我们可以通过 `Event` 构造函数创建自定义对象，它接受如下两个参数：

*   表示事件名称的字符串；
*   `EventInit` 对象，为可选参数，有下列属性：

*   `bubbles`：事件是否应该冒泡，默认值为 `false`；
*   `cancelable`：事件是否可以被取消，默认值为 `false`；
*   `scoped`：实验特性，可参考 [MDN Event.scoped](https://developer.mozilla.org/en-US/docs/Web/API/Event/scoped)。

因而我们首先通过如下代码创建三连击事件 `tripleClick`：

```javascript
var tripleClick = new Event(“tripleClick”);
```

然后通过监听 `click` 事件判断是否已经连续点击三次，若已经点击三次，则通过 `elem.dispatchEvent(tripleEvent)` 触发事件，这里需要注意的是判断点击之间的间隔，若间隔过长则重新开始计数，具体的代码如下：

```javascript
var button = document.getElementById(“btn”);
var counter = 0;
var lastClickTime = 0;
button.addEventListener(“click”, function (event) {
    event.preventDefault();
    if (counter == 0) {
        counter = 1;
    }
    else if (Date.now() - lastClickTime < 500) {
        // check click interval
        counter += 1;
    }
    else {
        // interval is too long, count from the beginning
        counter = 1;
    }
    lastClickTime = Date.now();
    if (counter == 3 ) {
        event.target.dispatchEvent(tripleClick);
    }
});
```

最后在 DOM 元素上监听 `tripleClick` 事件即可：

```javascript
button.addEventListener(“tripleClick”, function (event) {
    alert(“三连击达成！”);
    counter = 0;
});
```

完整的例子如下所示：

<iframe width="100%" height="150" src="//jsfiddle.net/Leonard_Peng/269hc99n/4/embedded/result" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

## 实现与 DOM 无关的事件

自定义与 DOM 无关事件的关键在于创建一个观察者，也就是是管理事件的对象，通过它来监听事件。一个基本的模式如下所示：

```javascript
var EventTarget = function () {
    this.handlers = {};
};
EventTarget.prototype = {
    constructor: EventTarget,
    addHandler: function (type, handler) {
        if (typeof this.handlers[type] === ‘undefined’) {
            this.handlers[type] = [];
        }
        this.handlers[type].push(handler);
    },
    removeHandler: function (type, handler) {
        if (typeof this.handlers[type] === ‘undefined’) return;
        var handlers = this.handlers[type];
        var i;
        for (i = 0; i < handler.length; i++) {
            if (handlers[i] === handler) {
                break;
            }
        }
        handlers.splice(i, 1);
    },
    fire: function (event) {
        if (!event.target) {
            event.target = this;
        }
        if (typeof this.handlers[event.type] === ‘undefined’) return;
        var handlers = this.handlers[event.type];
        for (var i = 0; i < handlers.length; i++) {
            handlersi;
        }
    }
};
```

这里 `EventTarget`就是一个管理事件的对象，它的属性 `handlers` 用于存储事件处理程序，原型中三个方法的作用依次为：

*   `addHandler`：注册给定类型的事件处理程序；
*   `removeHandler`：移除某个类型的事件处理程序；
*   `fire`：触发某个事件。

具体的使用如下所示：

```javascript
function handleMessage(event) {
    console.log(“Message received: “ + event.message);
}
// 创建一个新对象
var target = new EventTarget();
// 添加一个事件处理程序
target.addHandler(‘message’, handleMessage);
// 触发事件
target.fire({type: ‘message’, message: ‘Hello World!’});
// 移除事件处理程序
target.removeHandler(‘message’, handleMessage);
// 再次尝试触发事件处理程序，失败
target.fire({type: ‘message’, message: ‘Hello World, again!’});
// 输出为：
// Hello World!
```

从这段代码中，我们可以看到：触发事件的代码和监听事件的代码相互分离，而且事件具体的处理逻辑也可以封装在某一函数中。这样就可以很好地降低模块之间的耦合度，保持功能的隔离。

这里运用的是观察者模式，更多信息可以参考 [维基百科 - 观察者模式](https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F)。

## 参考资料

1.  [MDN - 创建和触发 events](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events)。
2.  《JavaScript 高级程序设计（第3版）》 22.4 节 - 自定义事件。